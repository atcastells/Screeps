<html>
<head>
<title>Creep.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
.s2 { color: rgb(0,0,0); }
.s3 { color: rgb(0,0,128); font-weight: bold; }
.s4 { color: rgb(0,0,255); }
.s5 { color: rgb(0,128,0); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
Creep.js</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">/** 
 * 
 * </span><span class="s1">@class</span><span class="s0"> 
 * </span><span class="s1">@extends </span><span class="s0">{RoomObject} 
 */</span><span class="s2"> 
Creep = </span><span class="s3">function</span><span class="s2">() { }; 
 
Creep.prototype = 
{ 
    </span><span class="s0">/** 
     * An array describing the creep’s body 
     * 
     * </span><span class="s1">@type </span><span class="s0">{Array&lt;{boost:string, type:string, hits:number}&gt;} 
     * 
     * </span><span class="s1">@note </span><span class="s0">boost: If the body part is boosted, this property specifies the mineral type which is used for boosting. One of the RESOURCE_* constants. 
     * </span><span class="s1">@note </span><span class="s0">type: One of the body part types constants. 
     * </span><span class="s1">@note </span><span class="s0">hits: The remaining amount of hit points of this body part. 
     * 
     */</span><span class="s2"> 
    body: [], 
 
    </span><span class="s0">/** 
     * An object with the creep's cargo contents. 
     * Each object key is one of the RESOURCE_* constants, values are resources amounts. 
     * Use _.sum(creep.carry) to get the total amount of contents. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{object&lt;string, number&gt;} 
     */</span><span class="s2"> 
    carry: {}, 
 
    </span><span class="s0">/** 
     * The total amount of resources the creep can carry. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{number} 
     */</span><span class="s2"> 
    carryCapacity: </span><span class="s4">0</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * The movement fatigue indicator. If it is greater than zero, the creep cannot move. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{number} 
     */</span><span class="s2"> 
    fatigue: </span><span class="s4">0</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * The current amount of hit points of the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{number} 
     */</span><span class="s2"> 
    hits: </span><span class="s4">0</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * The maximum amount of hit points of the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{number} 
     */</span><span class="s2"> 
    hitsMax: </span><span class="s4">0</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * A unique object identificator. 
     * You can use Game.getObjectById method to retrieve an object instance by its id. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{string} 
     */</span><span class="s2"> 
    id: </span><span class="s5">&quot;&quot;</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * A shorthand to Memory.creeps[creep.name]. 
     * You can use it for quick access the creep’s specific memory data object. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{*} 
     */</span><span class="s2"> 
    memory: {}, 
 
    </span><span class="s0">/** 
     * Whether it is your creep or foe. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{boolean} 
     */</span><span class="s2"> 
    my: </span><span class="s3">true</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * Creep’s name. 
     * You can choose the name while creating a new creep, and it cannot be changed later. 
     * This name is a hash key to access the creep via the Game.creeps object. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{string} 
     */</span><span class="s2"> 
    name: </span><span class="s5">&quot;&quot;</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * An object with the creep’s owner info 
     * 
     * </span><span class="s1">@type </span><span class="s0">{{username:string}} 
     */</span><span class="s2"> 
    owner: 
    { 
        username: </span><span class="s5">&quot;&quot;</span><span class="s2"> 
    }, 
 
    </span><span class="s0">/** 
     * Whether this creep is still being spawned. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{boolean} 
     */</span><span class="s2"> 
    spawning: </span><span class="s3">false</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * The remaining amount of game ticks after which the creep will die. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{number} 
     */</span><span class="s2"> 
    ticksToLive: </span><span class="s4">0</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * Attack another creep or structure in a short-ranged attack. 
     * Requires the ATTACK body part. 
     * If the target is inside a rampart, then the rampart is attacked instead. 
     * The target has to be at adjacent square to the creep. 
     * If the target is a creep with ATTACK body parts and is not inside a rampart, it will automatically hit back at the attacker. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Creep|Spawn|Structure} target The target object to be attacked. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    attack: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Decreases the controller's downgrade or reservation timer for 1 tick per every 5 CLAIM body parts (so the creep must have at least 5xCLAIM). 
     * The controller under attack cannot be upgraded for the next 1,000 ticks. 
     * The target has to be at adjacent square to the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{StructureController} target The target controller object. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    attackController: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Build a structure at the target construction site using carried energy. 
     * Requires WORK and CARRY body parts. 
     * The target has to be within 3 squares range of the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{ConstructionSite} target The target construction site to be built. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NOT_ENOUGH_RESOURCES|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART|ERR_RCL_NOT_ENOUGH} 
     */</span><span class="s2"> 
    build: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Cancel the order given during the current game tick. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string} methodName The name of a creep's method to be cancelled. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_FOUND} 
     */</span><span class="s2"> 
    cancelOrder: </span><span class="s3">function</span><span class="s2">(methodName) { }, 
 
    </span><span class="s0">/** 
     * Claims a neutral controller under your control. 
     * Requires the CLAIM body part. 
     * The target has to be at adjacent square to the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{StructureController} target The target controller object. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_FULL|ERR_NOT_IN_RANGE|ERR_NO_BODYPART|ERR_GCL_NOT_ENOUGH} 
     */</span><span class="s2"> 
    claimController: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Dismantles any (even hostile) structure returning 50% of the energy spent on its repair. 
     * Requires the WORK body part. 
     * If the creep has an empty CARRY body part, the energy is put into it; otherwise it is dropped on the ground. 
     * The target has to be at adjacent square to the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Spawn|Structure} target The target structure. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    dismantle: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Drop this resource on the ground. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string} resourceType One of the RESOURCE_* constants. 
     * </span><span class="s1">@param </span><span class="s0">{number} [amount] The amount of resource units to be dropped. If omitted, all the available carried amount is used. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NOT_ENOUGH_RESOURCES} 
     */</span><span class="s2"> 
    drop: </span><span class="s3">function</span><span class="s2">(resourceType, amount) { }, 
 
    </span><span class="s0">/** 
     * Get the quantity of live body parts of the given type. 
     * Fully damaged parts do not count. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string} type A body part type, one of the following body part constants: MOVE, WORK, CARRY, ATTACK, RANGED_ATTACK, HEAL, TOUGH 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number} A number representing the quantity of body parts. 
     */</span><span class="s2"> 
    getActiveBodyParts: </span><span class="s3">function</span><span class="s2">(type) { }, 
 
    </span><span class="s0">/** 
     * Harvest energy from the source or minerals from the mineral deposit. 
     * Requires the WORK body part. 
     * If the creep has an empty CARRY body part, the harvested resource is put into it; otherwise it is dropped on the ground. 
     * The target has to be at an adjacent square to the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Source|Mineral} target The object to be harvested. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NOT_FOUND|ERR_NOT_ENOUGH_RESOURCES|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    harvest: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Heal self or another creep. 
     * It will restore the target creep’s damaged body parts function and increase the hits counter. 
     * Requires the HEAL body part. 
     * The target has to be at adjacent square to the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Creep} target The target creep object. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    heal: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Move the creep one square in the specified direction. 
     * Requires the MOVE body part. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} direction One of the following constants: TOP, TOP_RIGHT, RIGHT, BOTTOM_RIGHT, BOTTOM, BOTTOM_LEFT, LEFT, TOP_LEFT 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_TIRED|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    move: </span><span class="s3">function</span><span class="s2">(direction) { }, 
 
    </span><span class="s0">/** 
     * Move the creep using the specified predefined path. 
     * Requires the MOVE body part. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Array|string} path A path value as returned from Room.findPath or RoomPosition.findPathTo methods. Both array form and serialized string form are accepted. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NOT_FOUND|ERR_INVALID_ARGS|ERR_TIRED|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    moveByPath: </span><span class="s3">function</span><span class="s2">(path) { }, 
 
    </span><span class="s0">/** 
     * Find the optimal path to the target within the same room and move to it. 
     * A shorthand to consequent calls of pos.findPathTo() and move() methods. 
     * If the target is in another room, then the corresponding exit will be used as a target. 
     * Requires the MOVE body part. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} x X position of the target in the same room. 
     * </span><span class="s1">@param </span><span class="s0">{number} y Y position of the target in the same room. 
     * </span><span class="s1">@param </span><span class="s0">{object} [opts] An object containing additional options 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.reusePath] This option enables reusing the path found along multiple game ticks. It allows to save CPU time, but can result in a slightly slower creep reaction behavior. The path is stored into the creep's memory to the _move property. The reusePath value defines the amount of ticks which the path should be reused for. The default value is 5. Increase the amount to save more CPU, decrease to make the movement more consistent. Set to 0 if you want to disable path reusing. 
     * </span><span class="s1">@param </span><span class="s0">{boolean} [opts.serializeMemory] If reusePath is enabled and this option is set to true, the path will be stored in memory in the short serialized form using Room.serializePath. The default value is true. 
     * </span><span class="s1">@param </span><span class="s0">{boolean} [opts.noPathFinding] If this option is set to true, moveTo method will return ERR_NOT_FOUND if there is no memorized path to reuse. This can significantly save CPU time in some cases. The default value is false. 
     * </span><span class="s1">@note </span><span class="s0">opts also supports any method from the Room.findPath options. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_TIRED|ERR_NO_BODYPART|ERR_INVALID_TARGET|ERR_NO_PATH} 
     */</span><span class="s2"> 
    moveTo: </span><span class="s3">function</span><span class="s2">(x, y, opts) { }, 
 
    </span><span class="s0">/** 
     * Toggle auto notification when the creep is under attack. 
     * The notification will be sent to your account email. 
     * Turned on by default. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{boolean} enabled Whether to enable notification or disable. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_INVALID_ARGS} 
     */</span><span class="s2"> 
    notifyWhenAttacked: </span><span class="s3">function</span><span class="s2">(enabled) { }, 
 
    </span><span class="s0">/** 
     * Pick up an item (a dropped piece of energy). 
     * Requires the CARRY body part. 
     * The target has to be at adjacent square to the creep or at the same square. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Resource} target The target object to be picked up. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_FULL|ERR_NOT_IN_RANGE} 
     */</span><span class="s2"> 
    pickup: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * A ranged attack against another creep or structure. 
     * Requires the RANGED_ATTACK body part. 
     * If the target is inside a rampart, the rampart is attacked instead. 
     * The target has to be within 3 squares range of the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Creep|Spawn|Structure} target The target object to be attacked. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    rangedAttack: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Heal another creep at a distance. 
     * It will restore the target creep’s damaged body parts function and increase the hits counter. 
     * Requires the HEAL body part. 
     * The target has to be within 3 squares range of the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Creep} target The target creep object. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    rangedHeal: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * A ranged attack against all hostile creeps or structures within 3 squares range. 
     * Requires the RANGED_ATTACK body part. 
     * The attack power depends on the range to each target. 
     * Friendly units are not affected. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    rangedMassAttack: </span><span class="s3">function</span><span class="s2">() { }, 
 
    </span><span class="s0">/** 
     * Repair a damaged structure using carried energy. 
     * Requires the WORK and CARRY body parts. 
     * The target has to be within 3 squares range of the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Spawn|Structure} target The target structure to be repaired. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NOT_ENOUGH_RESOURCES|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    repair: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Temporarily block a neutral controller from claiming by other players. 
     * Each tick, this command increases the counter of the period during which the controller is unavailable by 1 tick per each CLAIM body part. 
     * The maximum reservation period to maintain is 5,000 ticks. 
     * The target has to be at adjacent square to the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{StructureController} target The target controller object to be reserved. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    reserveController: </span><span class="s3">function</span><span class="s2">(target) { }, 
 
    </span><span class="s0">/** 
     * Display a visual speech balloon above the creep with the specified message. 
     * The message will disappear after a few seconds. 
     * Useful for debugging purposes. 
     * Only the creep's owner can see the speech message. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string} message The message to be displayed. Maximum length is 10 characters. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY} 
     */</span><span class="s2"> 
    say: </span><span class="s3">function</span><span class="s2">(message) { }, 
 
    </span><span class="s0">/** 
     * Kill the creep immediately. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY} 
     */</span><span class="s2"> 
    suicide: </span><span class="s3">function</span><span class="s2">() { }, 
 
    </span><span class="s0">/** 
     * Transfer resource from the creep to another object. 
     * The target has to be at adjacent square to the creep. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Creep|Spawn|Structure} target The target object. 
     * </span><span class="s1">@param </span><span class="s0">{string} resourceType One of the RESOURCE_* constants. 
     * </span><span class="s1">@param </span><span class="s0">{number} [amount] The amount of resources to be transferred. If omitted, all the available carried amount is used. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NOT_ENOUGH_RESOURCES|ERR_INVALID_TARGET|ERR_FULL|ERR_NOT_IN_RANGE|ERR_INVALID_ARGS} 
     */</span><span class="s2"> 
    transfer: </span><span class="s3">function</span><span class="s2">(target, resourceType, amount) { }, 
 
    </span><span class="s0">/** 
     * Upgrade your controller to the next level using carried energy. 
     * Upgrading controllers raises your Global Control Level in parallel. 
     * Requires WORK and CARRY body parts. 
     * The target has to be within 3 squares range of the creep. 
     * A fully upgraded level 8 controller can't be upgraded with the power over 15 energy units per tick regardless of creeps power. 
     * The cumulative effect of all the creeps performing upgradeController in the current tick is taken into account. 
     * The effect can be boosted by ghodium mineral compounds (including limit increase). 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{StructureController} target The target controller object to be upgraded. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_NOT_OWNER|ERR_BUSY|ERR_NOT_ENOUGH_RESOURCES|ERR_INVALID_TARGET|ERR_NOT_IN_RANGE|ERR_NO_BODYPART} 
     */</span><span class="s2"> 
    upgradeController: </span><span class="s3">function</span><span class="s2">(target) { } 
}; 
</span></pre>
</body>
</html>
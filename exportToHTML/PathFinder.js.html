<html>
<head>
<title>PathFinder.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
.s2 { color: rgb(0,0,0); }
.s3 { color: rgb(0,0,128); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
PathFinder.js</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">/** 
 * 
 * </span><span class="s1">@class</span><span class="s0"> 
 */</span><span class="s2"> 
PathFinder = </span><span class="s3">function</span><span class="s2">() { }; 
 
PathFinder.prototype = 
{ 
    </span><span class="s0">/** 
     * Find an optimal path between origin and goal. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{RoomPosition} origin The start position. 
     * </span><span class="s1">@param </span><span class="s0">{object} goal A goal or an array of goals. If more than one goal is supplied then the cheapest path found out of all the goals will be returned. A goal is either a RoomPosition or an object as defined below. 
                       Important: Please note that if your goal is not walkable (for instance, a source) then you should set range to at least 1 or else you will waste many CPU cycles searching for a target that you can't walk on. 
 
                       pos 
                       RoomPosition 
                       The target. 
                       range 
                       number 
                       Range to pos before goal is considered reached. The default is 0. 
     * </span><span class="s1">@param </span><span class="s0">{object} [opts] An object containing additional pathfinding flags. 
     * </span><span class="s1">@param </span><span class="s0">{function} [opts.roomCallback] Request from the pathfinder to generate a CostMatrix for a certain room. The callback accepts one argument, roomName. This callback will only be called once per room per search. If you are running multiple pathfinding operations in a single room and in a single tick you may consider caching your CostMatrix to speed up your code. Please read the CostMatrix documentation below for more information on CostMatrix. If you return false from the callback the requested room will not be searched, and it won't count against maxRooms 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.plainCost] Cost for walking on plain positions. The default is 1. 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.swampCost] Cost for walking on swamp positions. The default is 5. 
     * </span><span class="s1">@param </span><span class="s0">{boolean} [opts.flee] Instead of searching for a path to the goals this will search for a path away from the goals. The cheapest path that is out of range of every goal will be returned. The default is false. 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.maxOps] The maximum allowed pathfinding operations. You can limit CPU time used for the search based on ratio 1 op ~ 0.001 CPU. The default value is 2000. 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.maxRooms] The maximum allowed rooms to search. The default (and maximum) is 16. 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.heuristicWeight] Weight to apply to the heuristic in the A* formula F = G + weight * H. Use this option only if you understand the underlying A* algorithm mechanics! The default value is 1.2. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{{path:Array&lt;RoomPosition&gt;,opts:number}} An object containing: path - An array of RoomPosition objects; ops - Total number of operations performed before this path was calculated. 
     */</span><span class="s2"> 
    search: </span><span class="s3">function</span><span class="s2">(origin, goal, opts) { }, 
 
    </span><span class="s0">/** 
     * Specify whether to use this new experimental pathfinder in game objects methods. 
     * This method should be invoked every tick. 
     * 
     * </span><span class="s1">@note </span><span class="s0">It affects the following methods behavior: Room.findPath, RoomPosition.findPathTo, RoomPosition.findClosestByPath, Creep.moveTo. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{boolean} isEnabled Whether to activate the new pathfinder or deactivate. 
     */</span><span class="s2"> 
    use: </span><span class="s3">function</span><span class="s2">(isEnabled) { } 
}; 
 
</span><span class="s0">/** 
 * Creates a new CostMatrix containing 0's for all positions. 
 * 
 * </span><span class="s1">@constructor</span><span class="s0"> 
 * </span><span class="s1">@class</span><span class="s0"> 
 */</span><span class="s2"> 
PathFinder.CostMatrix = </span><span class="s3">function</span><span class="s2">() { }; 
 
PathFinder.CostMatrix.prototype = 
{ 
    </span><span class="s0">/** 
     * Set the cost of a position in this CostMatrix. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} x X position in the room. 
     * </span><span class="s1">@param </span><span class="s0">{number} y Y position in the room. 
     * </span><span class="s1">@param </span><span class="s0">{number} cost Cost of this position. Must be a whole number. A cost of 0 will use the terrain cost for that tile. A cost greater than or equal to 255 will be treated as unwalkable. 
     */</span><span class="s2"> 
    </span><span class="s3">set</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(x, y, cost) { }, 
 
    </span><span class="s0">/** 
     * Get the cost of a position in this CostMatrix. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} x X position in the room. 
     * </span><span class="s1">@param </span><span class="s0">{number} y Y position in the room. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number} 
     */</span><span class="s2"> 
    </span><span class="s3">get</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(x, y) { }, 
 
    </span><span class="s0">/** 
     * Copy this CostMatrix into a new CostMatrix with the same data. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@return </span><span class="s0">{CostMatrix} 
     */</span><span class="s2"> 
    clone: </span><span class="s3">function</span><span class="s2">() { }, 
 
    </span><span class="s0">/** 
     * Returns a compact representation of this CostMatrix which can be stored via JSON.stringify 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@return </span><span class="s0">{Array&lt;number&gt;} An array of numbers. There's not much you can do with the numbers besides store them for later. 
     */</span><span class="s2"> 
    serialize: </span><span class="s3">function</span><span class="s2">() { }, 
 
    </span><span class="s0">/** 
     * Static method which deserializes a new CostMatrix using the return value of serialize. 
     * </span><span class="s1">@static</span><span class="s0"> 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{object} val Whatever serialize returned 
     * 
     * </span><span class="s1">@return </span><span class="s0">{CostMatrix} 
     */</span><span class="s2"> 
    deserialize: </span><span class="s3">function</span><span class="s2">(val) { } 
}; 
</span></pre>
</body>
</html>
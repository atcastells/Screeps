<html>
<head>
<title>Room.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
.s2 { color: rgb(0,0,0); }
.s3 { color: rgb(0,0,128); font-weight: bold; }
.s4 { color: rgb(0,0,255); }
.s5 { color: rgb(0,128,0); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
Room.js</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">/** 
 * An object representing the room in which your units and structures are in. 
 * It can be used to look around, find paths, etc. 
 * Every object in the room contains its linked Room instance in the room property. 
 * 
 * </span><span class="s1">@class</span><span class="s0"> 
 */</span><span class="s2"> 
Room = </span><span class="s3">function</span><span class="s2">() { }; 
 
Room.prototype = 
{ 
    </span><span class="s0">/** 
     * The Controller structure of this room, if present, otherwise undefined. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{undefined|StructureController} 
     */</span><span class="s2"> 
    controller: </span><span class="s3">null</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * Total amount of energy available in all spawns and extensions in the room. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{number} 
     */</span><span class="s2"> 
    energyAvailable: </span><span class="s4">0</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * Total amount of energyCapacity of all spawns and extensions in the room. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{number} 
     */</span><span class="s2"> 
    energyCapacityAvailable: </span><span class="s4">0</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * A shorthand to Memory.rooms[room.name]. 
     * You can use it for quick access the roomâ€™s specific memory data object. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{*} 
     */</span><span class="s2"> 
    memory: {}, 
 
    </span><span class="s0">/** 
     * The mode of the room 
     * 
     * </span><span class="s1">@type </span><span class="s0">{string|MODE_SIMULATION|MODE_SURVIVAL|MODE_WORLD|MODE_ARENA} 
     */</span><span class="s2"> 
    mode: </span><span class="s5">&quot;&quot;</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * The name of the room. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{string} 
     */</span><span class="s2"> 
    name: </span><span class="s5">&quot;&quot;</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * The Storage structure of this room, if present, otherwise undefined. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{undefined|StructureStorage} 
     */</span><span class="s2"> 
    storage: </span><span class="s3">null</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * The Terminal structure of this room, if present, otherwise undefined. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{undefined|StructureTerminal} 
     */</span><span class="s2"> 
    terminal: </span><span class="s3">null</span><span class="s2">, 
 
    </span><span class="s0">/** 
     * Serialize a path array into a short string representation, which is suitable to store in memory. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{Array} path A path array retrieved from Room.findPath. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{string} A serialized string form of the given path. 
     */</span><span class="s2"> 
    serializePath: </span><span class="s3">function</span><span class="s2">(path) { }, 
 
    </span><span class="s0">/** 
     * Deserialize a short string path representation into an array form. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string} path A serialized path string. 
     * 
     * return {Array} A path array. 
     */</span><span class="s2"> 
    deserializePath: </span><span class="s3">function</span><span class="s2">(path) { }, 
 
    </span><span class="s0">/** 
     * Create new ConstructionSite at the specified location. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} x The X position. 
     * </span><span class="s1">@param </span><span class="s0">{number} y The Y position. 
     * </span><span class="s1">@param </span><span class="s0">{string} structureType One of the STRUCTURE_* constants. 
     * 
     * </span><span class="s1">@note </span><span class="s0">Alternative function: createConstructionSite(pos, structureType) 
     * </span><span class="s1">@param </span><span class="s0">{object} pos Can be a RoomPosition object or any object containing RoomPosition. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|OK|ERR_INVALID_TARGET|ERR_FULL|ERR_INVALID_ARGS|ERR_RCL_NOT_ENOUGH} 
     */</span><span class="s2"> 
    createConstructionSite: </span><span class="s3">function</span><span class="s2">(x, y, structureType) { }, 
 
    </span><span class="s0">/** 
     * Create new Flag at the specified location. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} x The X position. 
     * </span><span class="s1">@param </span><span class="s0">{number} y The Y position. 
     * </span><span class="s1">@param </span><span class="s0">{string} [name] The name of a new flag. It should be unique, i.e. the Game.flags object should not contain another flag with the same name (hash key). If not defined, a random name will be generated. 
     * </span><span class="s1">@param </span><span class="s0">{string} [color] The color of a new flag. Should be one of the COLOR_* constants. The default value is COLOR_WHITE. 
     * </span><span class="s1">@param </span><span class="s0">{string} [secondaryColor] The secondary color of a new flag. Should be one of the COLOR_* constants. The default value is equal to color. 
     * 
     * </span><span class="s1">@note </span><span class="s0">Alternative function: createConstructionSite(pos, name, color, secondaryColor) 
     * </span><span class="s1">@param </span><span class="s0">{object} pos Can be a RoomPosition object or any object containing RoomPosition. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{number|ERR_NAME_EXISTS|ERR_INVALID_ARGS} 
     */</span><span class="s2"> 
    createFlag: </span><span class="s3">function</span><span class="s2">(x, y, name, color, secondaryColor) { }, 
 
    </span><span class="s0">/** 
     * Find all objects of the specified type in the room. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} type One of the FIND_* constants. 
     * </span><span class="s1">@param </span><span class="s0">{object} [opts] An object with additional options 
     * </span><span class="s1">@param </span><span class="s0">{object|function|string} [opts.filter] The result list will be filtered using the Lodash.filter method. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{Array} An array with the objects found. 
     */</span><span class="s2"> 
    find: </span><span class="s3">function</span><span class="s2">(type, opts) { }, 
 
    </span><span class="s0">/** 
     * Find the exit direction en route to another room. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string|Room} room Another room name or room object. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{FIND_EXIT_TOP|FIND_EXIT_RIGHT|FIND_EXIT_BOTTOM|FIND_EXIT_LEFT|number|ERR_NO_PATH|ERR_INVALID_ARGS} 
     */</span><span class="s2"> 
    findExitTo: </span><span class="s3">function</span><span class="s2">(room) { }, 
 
    </span><span class="s0">/** 
     * Find an optimal path inside the room between fromPos and toPos using A* search algorithm. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{RoomPosition} fromPos The start position. 
     * </span><span class="s1">@param </span><span class="s0">{RoomPosition} toPos The end position. 
     * </span><span class="s1">@param </span><span class="s0">{object} [opts] An object containing additonal pathfinding flags 
     * </span><span class="s1">@param </span><span class="s0">{boolean} [opts.ignoreCreeps] Treat squares with creeps as walkable. Can be useful with too many moving creeps around or in some other cases. The default value is false. 
     * </span><span class="s1">@param </span><span class="s0">{boolean} [opts.ignoreDestructibleStructures] Treat squares with destructible structures (constructed walls, ramparts, spawns, extensions) as walkable. Use this flag when you need to move through a territory blocked by hostile structures. If a creep with an ATTACK body part steps on such a square, it automatically attacks the structure. The default value is false. 
     * </span><span class="s1">@param </span><span class="s0">{boolean} [opts.ignoreRoads] Ignore road structures. Enabling this option can speed up the search. The default value is false. This is only used when the new PathFinder is enabled. 
     * </span><span class="s1">@param </span><span class="s0">{function(string, CostMatrix)} [opts.costCallback] You can use this callback to modify a CostMatrix for any room during the search. The callback accepts two arguments, roomName and costMatrix. Use the costMatrix instance to make changes to the positions costs. If you return a new matrix from this callback, it will be used instead of the built-in cached one. This option is only used when the new PathFinder is enabled. 
     * </span><span class="s1">@param </span><span class="s0">{Array} [opts.ignore] An array of the room's objects or RoomPosition objects which should be treated as walkable tiles during the search. This option cannot be used when the new PathFinder is enabled (use costCallback option instead). 
     * </span><span class="s1">@param </span><span class="s0">{Array} [opts.avoid] An array of the room's objects or RoomPosition objects which should be treated as obstacles during the search. This option cannot be used when the new PathFinder is enabled (use costCallback option instead). 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.maxOps] The maximum limit of possible pathfinding operations. You can limit CPU time used for the search based on ratio 1 op ~ 0.001 CPU. The default value is 2000. 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.heuristicWeight] Weight to apply to the heuristic in the A* formula F = G + weight * H. Use this option only if you understand the underlying A* algorithm mechanics! The default value is 1.2. 
     * </span><span class="s1">@param </span><span class="s0">{boolean} [opts.serialize] If true, the result path will be serialized using Room.serializePath. The default is false. 
     * </span><span class="s1">@param </span><span class="s0">{number} [opts.maxRooms] The maximum allowed rooms to search. The default (and maximum) is 16. This is only used when the new PathFinder is enabled. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{Array} An array with path steps in the following format: 
                         [ 
                             { x: 10, y: 5, dx: 1,  dy: 0, direction: RIGHT }, 
                             { x: 10, y: 6, dx: 0,  dy: 1, direction: BOTTOM }, 
                             { x: 9,  y: 7, dx: -1, dy: 1, direction: BOTTOM_LEFT }, 
                             ... 
                         ] 
 
     */</span><span class="s2"> 
    findPath: </span><span class="s3">function</span><span class="s2">(fromPos, toPos, opts) { }, 
 
    </span><span class="s0">/** 
     * Creates a RoomPosition object at the specified location. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} x The X position. 
     * </span><span class="s1">@param </span><span class="s0">{number} y The Y position. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{null|RoomPosition} 
     */</span><span class="s2"> 
    getPositionAt: </span><span class="s3">function</span><span class="s2">(x, y) { }, 
 
    </span><span class="s0">/** 
     * Get the list of objects at the specified room position. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} x X position in the room. 
     * </span><span class="s1">@param </span><span class="s0">{number} y Y position in the room. 
     * 
     * </span><span class="s1">@note </span><span class="s0">Alternative function: lookAt(target) 
     * </span><span class="s1">@param </span><span class="s0">{object} target Can be a RoomPosition object or any object containing RoomPosition. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{Array} An array with objects at the specified position in the following format: 
                         [ 
                             { type: 'creep', creep: {...} }, 
                             { type: 'structure', structure: {...} }, 
                             ... 
                             { type: 'terrain', terrain: 'swamp' } 
                         ] 
     */</span><span class="s2"> 
    lookAt: </span><span class="s3">function</span><span class="s2">(x, y) { }, 
 
    </span><span class="s0">/** 
     * Get the list of objects at the specified room area. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{number} top The top Y boundary of the area. 
     * </span><span class="s1">@param </span><span class="s0">{number} left The left X boundary of the area. 
     * </span><span class="s1">@param </span><span class="s0">{number} bottom The bottom Y boundary of the area. 
     * </span><span class="s1">@param </span><span class="s0">{number} right The right X boundary of the area. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{object} An object with all the objects in the specified area in the following format: 
                        // 10,5,11,7 
                         { 
                            10 : 
                            { 
                                5 : 
                                [ 
                                    { 
                                        type : 'creep', 
                                        creep : 
                                        { 
                                            ... 
                                        } 
                                    }, 
                                    { 
                                        type : 'terrain', 
                                        terrain : 'swamp' 
                                    } 
                                ], 
                                6 : 
                                [ 
                                    { 
                                        type : 'terrain', 
                                        terrain : 'swamp' 
                                    } 
                                ], 
                                7 : 
                                [ 
                                    { 
                                        type : 'terrain', 
                                        terrain : 'swamp' 
                                    } 
                                ] 
                            }, 
                            11 : 
                            { 
                                5 : 
                                [ 
                                    { 
                                        type : 'terrain', 
                                        terrain : 'normal' 
                                    } 
                                ], 
                                6 : 
                                [ 
                                    { 
                                        type : 'structure', 
                                        structure : 
                                        { 
                                            ... 
                                        } 
                                    }, 
                                    { 
                                        type : 'terrain', 
                                        terrain : 'swamp' 
                                    } 
                                ], 
                                7 : 
                                [ 
                                    { 
                                        type : 'terrain', 
                                        terrain : 'wall' 
                                    } 
                                ] 
                            } 
                        } 
     */</span><span class="s2"> 
    lookAtArea: </span><span class="s3">function</span><span class="s2">(top, left, bottom, right) { }, 
 
    </span><span class="s0">/** 
     * Get an object with the given type at the specified room position. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string} type One of the LOOK_* constants. 
     * </span><span class="s1">@param </span><span class="s0">{number} x X position in the room. 
     * </span><span class="s1">@param </span><span class="s0">{number} y Y position in the room. 
     * 
     * </span><span class="s1">@note </span><span class="s0">Alternative function: lookForAt(type, target) 
     * </span><span class="s1">@param </span><span class="s0">{object} target Can be a RoomPosition object or any object containing RoomPosition. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{Array} An array of objects of the given type at the specified position if found. 
     */</span><span class="s2"> 
    lookForAt: </span><span class="s3">function</span><span class="s2">(type, x, y) { }, 
 
    </span><span class="s0">/** 
     * Get the list of objects with the given type at the specified room area. 
     * 
     * </span><span class="s1">@type </span><span class="s0">{function} 
     * 
     * </span><span class="s1">@param </span><span class="s0">{string} type One of the LOOK_* constants. 
     * </span><span class="s1">@param </span><span class="s0">{number} top The top Y boundary of the area. 
     * </span><span class="s1">@param </span><span class="s0">{number} left The left X boundary of the area. 
     * </span><span class="s1">@param </span><span class="s0">{number} bottom The bottom Y boundary of the area. 
     * </span><span class="s1">@param </span><span class="s0">{number} right The right X boundary of the area. 
     * 
     * </span><span class="s1">@return </span><span class="s0">{object} An object with all the objects of the given type in the specified area in the following format: 
                        //10,5,11,7 
                        { 
                            10: 
                            { 
                                5: [{...}], 
                                6: undefined, 
                                7: undefined 
                            }, 
                            11: 
                            { 
                                5: undefined, 
                                6: [{...}, {...}], 
                                7: undefined 
                            } 
                        } 
     */</span><span class="s2"> 
    lookForAtArea: </span><span class="s3">function</span><span class="s2">(type, top, left, bottom, right) { } 
}; 
</span></pre>
</body>
</html>